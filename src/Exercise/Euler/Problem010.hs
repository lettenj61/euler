module Exercise.Euler.Problem010 where

import Data.Char (digitToInt)
import Data.List (tails)

-- If we list all the natural numbers below 10 that are multiples of 3 or 5,
-- we get 3, 5, 6 and 9. The sum of these multiples is 23.
-- Find the sum of all the multiples of 3 or 5 below 1000.
problem1 :: Int
problem1 = sum $ filter (\n -> n `mod` 3 == 0 || n `mod` 5 == 0) [1..999]

-- Each new term in the Fibonacci sequence is generated by adding the previous two terms.
-- By starting with 1 and 2, the first 10 terms will be:
--   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
-- By considering the terms in the Fibonacci sequence whose values do not exceed four million,
-- find the sum of the even-valued terms.
problem2 :: Int
problem2 = sum $ filter even $ takeWhile (\n -> n < 4000000) fibs where
  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

-- The prime factors of 13195 are 5, 7, 13 and 29.
-- What is the largest prime factor of the number 600851475143 ?
problem3 :: Int
problem3 = maximum $ primeFactors 600851475143 where
  primeFactors 1 = []
  primeFactors x = v : (primeFactors $ x `div` v) where
    v = (factors x) !! 1
    factors n = [x | x <- [1..n], n `mod` x == 0]

-- A palindromic number reads the same both ways.
-- The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
-- Find the largest palindrome made from the product of two 3-digit numbers.
problem4 :: Int
problem4 = maximum $ filter isPalindrome products where
  isPalindrome xs =
    let s = show (xs) in s == (reverse s)
  products = [i * j | i <- threeDigits, j <- threeDigits]
  threeDigits = [1..999]

-- 2520 is the smallest number that can be divided by each of the numbers from 1 to 10
-- without any remainder.
-- What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
problem5 :: Int
problem5 = head $ filter evenlyDivisible steps where
  steps = iterate (+ 20) 20
  evenlyDivisible x = all (\n -> x `mod` n == 0) [2..20]

-- The sum of the squares of the first ten natural numbers is,
--     12 + 22 + ... + 102 = 385
-- The square of the sum of the first ten natural numbers is,
--     (1 + 2 + ... + 10)2 = 552 = 3025
-- Hence the difference between the sum of the squares of the
-- first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
-- Find the difference between the sum of the squares of the first one hundred
-- natural numbers and the square of the sum.
problem6 :: Int
problem6 = diff 100 where
  diff n = (squareOfSums n) - (sumOfSquares n)
  sumOfSquares n = sum [x*x | x <- [1..n]]
  squareOfSums n = (sum [1..n]) * (sum [1..n])

-- By listing the first six prime numbers:
-- 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
-- What is the 10 001st prime number?
problem7 :: Int
problem7 = primes !! 10000
  where
    primes  = map fromIntegral $ [2, 3] ++ primes'
    primes' = [5] ++ f 1 7 primes'
    f m s (p : ps) = [n | n <- ns, gcd m n == 1] ++ f (m * p) (p * p) ps
      where ns = [x + y | x <- [s, s + 6 .. p * p - 2], y <- [0, 4]]

-- The four adjacent digits in the 1000-digit number that have the greatest product are
-- 9 × 9 × 8 × 9 = 5832.
--
-- 73167176531330624919225119674426574742355349194934
-- 96983520312774506326239578318016984801869478851843
-- 85861560789112949495459501737958331952853208805511
-- 12540698747158523863050715693290963295227443043557
-- 66896648950445244523161731856403098711121722383113
-- 62229893423380308135336276614282806444486645238749
-- 30358907296290491560440772390713810515859307960866
-- 70172427121883998797908792274921901699720888093776
-- 65727333001053367881220235421809751254540594752243
-- 52584907711670556013604839586446706324415722155397
-- 53697817977846174064955149290862569321978468622482
-- 83972241375657056057490261407972968652414535100474
-- 82166370484403199890008895243450658541227588666881
-- 16427171479924442928230863465674813919123162824586
-- 17866458359124566529476545682848912883142607690042
-- 24219022671055626321111109370544217506941658960408
-- 07198403850962455444362981230987879927244284909188
-- 84580156166097919133875499200524063689912560717606
-- 05886116467109405077541002256983155200055935729725
-- 71636269561882670428252483600823257530420752963450
--
-- Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
-- What is the value of this product?
problem8 :: Int
problem8 = maximum $ map (product . parseInt) $ windows 13 (concat grid)
  where
    grid =
      [ "73167176531330624919225119674426574742355349194934"
      , "96983520312774506326239578318016984801869478851843"
      , "85861560789112949495459501737958331952853208805511"
      , "12540698747158523863050715693290963295227443043557"
      , "66896648950445244523161731856403098711121722383113"
      , "62229893423380308135336276614282806444486645238749"
      , "30358907296290491560440772390713810515859307960866"
      , "70172427121883998797908792274921901699720888093776"
      , "65727333001053367881220235421809751254540594752243"
      , "52584907711670556013604839586446706324415722155397"
      , "53697817977846174064955149290862569321978468622482"
      , "83972241375657056057490261407972968652414535100474"
      , "82166370484403199890008895243450658541227588666881"
      , "16427171479924442928230863465674813919123162824586"
      , "17866458359124566529476545682848912883142607690042"
      , "24219022671055626321111109370544217506941658960408"
      , "07198403850962455444362981230987879927244284909188"
      , "84580156166097919133875499200524063689912560717606"
      , "05886116467109405077541002256983155200055935729725"
      , "71636269561882670428252483600823257530420752963450" ]
    windows m = foldr (zipWith (:)) (repeat []) . take m . tails
    parseInt s = map digitToInt s
